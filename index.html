<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global Chat App</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #f0f0f0; }
        #login { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
        #chat { display: none; height: 100vh; display: flex; flex-direction: column; }
        #sidebar { width: 250px; background: #333; color: white; padding: 10px; overflow-y: auto; }
        #main { flex: 1; display: flex; flex-direction: column; }
        #lobbies { margin-bottom: 10px; }
        #lobby-list { list-style: none; padding: 0; }
        #lobby-list li { padding: 5px; cursor: pointer; }
        #lobby-list li.active { background: #555; }
        #users, #pending-reqs, #friends { margin-bottom: 10px; }
        #user-list, #pending-list, #friend-list { list-style: none; padding: 0; }
        #user-list li, #pending-list li, #friend-list li { padding: 5px; cursor: pointer; }
        #messages { flex: 1; padding: 10px; overflow-y: auto; background: white; border: 1px solid #ccc; }
        #input-area { display: flex; padding: 10px; background: #eee; }
        #message-input { flex: 1; padding: 5px; margin-right: 5px; }
        #send-btn { padding: 5px 10px; }
        .message { margin-bottom: 5px; padding: 5px; border-bottom: 1px solid #ddd; }
        .message.own { text-align: right; color: blue; }
        .private { background: #e0f7fa; }
        form { display: flex; flex-direction: column; width: 300px; }
        input, button { margin-bottom: 10px; padding: 5px; }
        button { background: #007bff; color: white; border: none; cursor: pointer; }
        button:hover { background: #0056b3; }
        button.small { font-size: 0.8em; padding: 2px 5px; margin-left: 5px; }
        #call-ui { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; justify-content: center; align-items: center; flex-direction: column; color: white; }
        #local-video, #remote-video { width: 300px; height: 200px; background: black; margin: 10px; }
        #call-controls { margin-top: 10px; }
        #call-controls button { margin: 0 5px; padding: 10px; }
        .call-btn { background: #28a745; }
        .call-btn:hover { background: #218838; }
        .end-btn { background: #dc3545; }
        .end-btn:hover { background: #c82333; }
        .incoming-call { background: #ffc107; color: #000; padding: 10px; margin: 5px 0; border-radius: 5px; }
        #notification { display: none; position: fixed; top: 20px; right: 20px; background: #007bff; color: white; padding: 10px; border-radius: 5px; z-index: 1001; }
    </style>
</head>
<body>
    <div id="login">
        <h1>Login / Register</h1>
        <form id="auth-form">
            <input type="text" id="username" placeholder="Username" required>
            <input type="password" id="password" placeholder="Password" required>
            <button type="submit">Login</button>
            <button type="button" id="register-btn">Register</button>
        </form>
    </div>
    <div id="chat">
        <div id="sidebar">
            <div id="lobbies">
                <h3>Lobbies</h3>
                <ul id="lobby-list"></ul>
                <input type="text" id="new-lobby" placeholder="New Lobby">
                <button id="create-lobby">Create</button>
            </div>
            <div id="users">
                <h3>Users Online</h3>
                <ul id="user-list"></ul>
            </div>
            <div id="pending-reqs">
                <h3>Pending Requests</h3>
                <ul id="pending-list"></ul>
            </div>
            <div id="friends">
                <h3>Friends</h3>
                <ul id="friend-list"></ul>
            </div>
            <button id="logout">Logout</button>
        </div>
        <div id="main">
            <div id="messages"></div>
            <div id="input-area">
                <input type="text" id="message-input" placeholder="Type a message...">
                <button id="send-btn">Send</button>
            </div>
        </div>
    </div>

    <!-- Call UI -->
    <div id="call-ui">
        <video id="local-video" autoplay muted playsinline></video>
        <video id="remote-video" autoplay playsinline></video>
        <div id="call-controls">
            <button id="mute-btn" class="call-btn">Mute</button>
            <button id="video-btn" class="call-btn">Video Off</button>
            <button id="end-call-btn" class="end-btn">End Call</button>
        </div>
        <div id="incoming-call" class="incoming-call" style="display: none;">
            <p>Incoming call from <span id="caller-name"></span></p>
            <button id="accept-call" class="call-btn">Accept</button>
            <button id="reject-call" class="end-btn">Reject</button>
        </div>
    </div>

    <!-- Notification -->
    <div id="notification"></div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js';
        import { getDatabase, ref, set, get, update, push, onValue, onChildAdded, onDisconnect, remove } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js';

        // REPLACE WITH YOUR FIREBASE CONFIG
        const firebaseConfig = {
            // apiKey: "your-api-key",
            // authDomain: "your-project.firebaseapp.com",
            // databaseURL: "https://your-project-default-rtdb.firebaseio.com",
            // projectId: "your-project",
            // storageBucket: "your-project.appspot.com",
            // messagingSenderId: "123",
            // appId: "your-app-id"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getDatabase(app);

        let currentUser = null;
        let currentUsername = null;
        let currentLobby = 'global';
        let currentPriv = null;
        let lobbiesData = {};
        let onlineUsers = {};
        let myFriends = [];
        let pendingReqs = [];
        let unsubscribeFuncs = [];
        let currentMessagesListener = null;

        // WebRTC Setup
        let localStream = null;
        let remoteStream = null;
        let peerConnection = null;
        let currentCall = null; // { type: 'voice'|'video', to: username, pc: peerConnection }
        const configuration = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] // Public STUN
        };

        const localVideo = document.getElementById('local-video');
        const remoteVideo = document.getElementById('remote-video');
        const callUi = document.getElementById('call-ui');
        const incomingCallDiv = document.getElementById('incoming-call');
        const callerName = document.getElementById('caller-name');
        const acceptBtn = document.getElementById('accept-call');
        const rejectBtn = document.getElementById('reject-call');
        const muteBtn = document.getElementById('mute-btn');
        const videoBtn = document.getElementById('video-btn');
        const endCallBtn = document.getElementById('end-call-btn');

        // Media Permissions
        async function getMedia(type = 'video') {
            const constraints = type === 'video' ? { video: true, audio: true } : { audio: true };
            try {
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                localVideo.srcObject = localStream;
                return localStream;
            } catch (err) {
                console.error('Media error:', err);
                alert('Could not access media devices');
            }
        }

        // Create Peer Connection
        function createPeerConnection(targetUsername, callType) {
            const pc = new RTCPeerConnection(configuration);
            currentCall = { type: callType, to: targetUsername, pc };

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    push(ref(db, `calls/${targetUsername}/candidates`), event.candidate);
                }
            };

            pc.ontrack = (event) => {
                remoteStream = event.streams[0];
                remoteVideo.srcObject = remoteStream;
            };

            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

            return pc;
        }

        // Signaling Functions
        async function startCall(targetUsername, callType) {
            await getMedia(callType);
            const pc = createPeerConnection(targetUsername, callType);
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            set(ref(db, `calls/${targetUsername}/${currentUsername}`), {
                type: callType,
                from: currentUsername,
                offer: pc.localDescription,
                timestamp: Date.now()
            });
        }

        async function acceptCall(callerUsername, callType) {
            await getMedia(callType);
            const pc = createPeerConnection(callerUsername, callType);
            const callRef = ref(db, `calls/${currentUsername}/${callerUsername}`);
            const snap = await get(callRef);
            const offer = snap.val().offer;
            await pc.setRemoteDescription(new RTCSessionDescription(offer));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            update(callRef, { answer: pc.localDescription });

            // Listen for candidates
            onChildAdded(ref(db, `calls/${currentUsername}/candidates`), (snap) => {
                const candidate = new RTCIceCandidate(snap.val());
                pc.addIceCandidate(candidate);
            });
        }

        async function handleIncomingCall(callerUsername, callData) {
            currentCall = { type: callData.type, to: callerUsername, pc: null };
            callerName.textContent = callerUsername;
            incomingCallDiv.style.display = 'block';
            callUi.style.display = 'flex';

            acceptBtn.onclick = () => {
                acceptBtn.disabled = true;
                acceptCall(callerUsername, callData.type);
                incomingCallDiv.style.display = 'none';
                showCallControls();
            };

            rejectBtn.onclick = () => {
                remove(ref(db, `calls/${currentUsername}/${callerUsername}`));
                endCall();
            };
        }

        function showCallControls() {
            muteBtn.style.display = 'inline';
            videoBtn.style.display = 'inline';
            endCallBtn.style.display = 'inline';
            incomingCallDiv.style.display = 'none';
        }

        // Call Controls
        muteBtn.onclick = () => {
            localStream.getAudioTracks()[0].enabled = !localStream.getAudioTracks()[0].enabled;
            muteBtn.textContent = localStream.getAudioTracks()[0].enabled ? 'Mute' : 'Unmute';
        };

        videoBtn.onclick = () => {
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                videoBtn.textContent = videoTrack.enabled ? 'Video Off' : 'Video On';
            }
        };

        endCallBtn.onclick = endCall;

        function endCall() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop());
                remoteStream = null;
            }
            currentCall = null;
            callUi.style.display = 'none';
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            incomingCallDiv.style.display = 'none';
            acceptBtn.disabled = false;
            muteBtn.textContent = 'Mute';
            videoBtn.textContent = 'Video Off';
            // Clean up DB
            if (currentUsername && currentCall?.to) {
                remove(ref(db, `calls/${currentUsername}/${currentCall.to}`));
                remove(ref(db, `calls/${currentCall.to}/${currentUsername}`));
            }
        }

        // Listen for calls
        function listenForCalls() {
            const callsUnsub = onValue(ref(db, `calls/${currentUsername}`), (snap) => {
                const calls = snap.val();
                if (calls) {
                    Object.keys(calls).forEach(caller => {
                        const callData = calls[caller];
                        if (!currentCall) { // Only handle if not in call
                            handleIncomingCall(caller, callData);
                        }
                    });
                }
            });
            unsubscribeFuncs.push(callsUnsub);

            // Listen for answers/candidates when initiating
            const myCallsUnsub = onValue(ref(db, `calls`), (snap) => {
                const rootCalls = snap.val();
                if (rootCalls && currentCall?.to) {
                    const answer = rootCalls[currentCall.to]?.[currentUsername]?.answer;
                    if (answer && peerConnection && peerConnection.remoteDescription === null) {
                        peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                    }
                    // Candidates for initiator
                    onChildAdded(ref(db, `calls/${currentCall.to}/candidates`), (candSnap) => {
                        if (peerConnection) {
                            const candidate = new RTCIceCandidate(candSnap.val());
                            peerConnection.addIceCandidate(candidate);
                        }
                    });
                }
            });
            unsubscribeFuncs.push(myCallsUnsub);
        }

        // Add call buttons to UI
        function addCallButtons(container, username, isFriend = false) {
            if (!isFriend && !myFriends.includes(username)) return; // Only call friends for simplicity
            const callBtn = document.createElement('button');
            callBtn.classList.add('small', 'call-btn');
            callBtn.textContent = 'Voice Call';
            callBtn.onclick = (e) => {
                e.stopPropagation();
                startCall(username, 'voice');
                callUi.style.display = 'flex';
                showNotification(`Calling ${username}...`);
            };
            container.appendChild(callBtn);

            const videoCallBtn = document.createElement('button');
            videoCallBtn.classList.add('small', 'call-btn');
            videoCallBtn.textContent = 'Video Call';
            videoCallBtn.onclick = (e) => {
                e.stopPropagation();
                startCall(username, 'video');
                callUi.style.display = 'flex';
                showNotification(`Video calling ${username}...`);
            };
            container.appendChild(videoCallBtn);
        }

        function showNotification(msg) {
            const notif = document.getElementById('notification');
            notif.textContent = msg;
            notif.style.display = 'block';
            setTimeout(() => notif.style.display = 'none', 3000);
        }

        // Attach real-time listeners
        function attachListeners() {
            unsubscribeFuncs.forEach(unsub => unsub());
            unsubscribeFuncs = [];

            // ... (existing listeners for lobbies, users, friends, pending)

            const lobbiesUnsub = onValue(ref(db, 'lobbies'), (snap) => {
                lobbiesData = snap.val() || {};
                updateLobbies();
            });
            unsubscribeFuncs.push(lobbiesUnsub);

            const usersUnsub = onValue(ref(db, 'users'), (snap) => {
                onlineUsers = {};
                snap.forEach((child) => {
                    const data = child.val();
                    if (data.online) {
                        onlineUsers[child.key] = data.username;
                    }
                });
                updateUsers();
            });
            unsubscribeFuncs.push(usersUnsub);

            const friendsUnsub = onValue(ref(db, `friends/${currentUsername}`), (snap) => {
                myFriends = snap.val() || [];
                updateFriends();
                updateUsers();
            });
            unsubscribeFuncs.push(friendsUnsub);

            const pendingUnsub = onValue(ref(db, `friendRequests/${currentUsername}`), (snap) => {
                pendingReqs = snap.val() || [];
                updatePending();
            });
            unsubscribeFuncs.push(pendingUnsub);

            // Set online and handle disconnect
            const userRef = ref(db, `users/${currentUser.uid}`);
            update(userRef, { online: true }).then(() => {
                onDisconnect(userRef).set({ online: false });
            });

            listenForCalls();
        }

        function detachListeners() {
            unsubscribeFuncs.forEach(unsub => unsub());
            unsubscribeFuncs = [];
            if (currentMessagesListener) {
                currentMessagesListener();
                currentMessagesListener = null;
            }
            endCall(); // End any active call
        }

        // Auth (unchanged)
        document.getElementById('auth-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value;
            const email = `${username}@globalchat.app`;
            try {
                await signInWithEmailAndPassword(auth, email, password);
            } catch (err) {
                alert('Invalid credentials');
            }
        });

        document.getElementById('register-btn').addEventListener('click', async () => {
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value;
            if (!username || !password) return;
            const email = `${username}@globalchat.app`;
            try {
                const cred = await createUserWithEmailAndPassword(auth, email, password);
                await set(ref(db, `users/${cred.user.uid}`), { username, online: true });
            } catch (err) {
                if (err.code === 'auth/email-already-in-use') {
                    alert('Username taken');
                } else {
                    alert(err.message);
                }
            }
        });

        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                currentUsername = user.email.split('@')[0];
                attachListeners();
                showChat();
            } else {
                detachListeners();
                currentUser = null;
                currentUsername = null;
                showLogin();
            }
        });

        function showChat() {
            document.getElementById('login').style.display = 'none';
            document.getElementById('chat').style.display = 'flex';
            updateLobbies();
            updateMessages();
        }

        function showLogin() {
            document.getElementById('chat').style.display = 'none';
            document.getElementById('login').style.display = 'flex';
            document.getElementById('username').value = '';
            document.getElementById('password').value = '';
        }

        // Ensure lobby exists
        async function ensureLobby(name) {
            const lobbyRef = ref(db, `lobbies/${name}`);
            const snap = await get(lobbyRef);
            if (!snap.exists()) {
                await set(lobbyRef, { messages: {} });
            }
        }

        // Lobbies (unchanged)
        document.getElementById('create-lobby').addEventListener('click', async () => {
            const name = document.getElementById('new-lobby').value.trim();
            if (name && !lobbiesData[name]) {
                await set(ref(db, `lobbies/${name}`), { messages: {} });
                document.getElementById('new-lobby').value = '';
            }
        });

        function updateLobbies() {
            ensureLobby(currentLobby);
            const list = document.getElementById('lobby-list');
            list.innerHTML = '';
            Object.keys(lobbiesData).forEach((lobby) => {
                const li = document.createElement('li');
                li.textContent = lobby;
                li.classList.toggle('active', lobby === currentLobby);
                li.addEventListener('click', () => {
                    currentLobby = lobby;
                    currentPriv = lobby.startsWith('priv_') ? lobby.split('_')[1] || lobby.split('_')[2] : null;
                    updateLobbies();
                    updateMessages();
                });
                list.appendChild(li);
            });
        }

        // Users - Add call buttons for friends
        function updateUsers() {
            const list = document.getElementById('user-list');
            list.innerHTML = '';
            Object.values(onlineUsers).filter(u => u !== currentUsername).forEach((user) => {
                const li = document.createElement('li');
                li.textContent = user;
                li.addEventListener('click', () => privMsg(user));
                if (!myFriends.includes(user)) {
                    const btn = document.createElement('button');
                    btn.classList.add('small');
                    btn.textContent = 'Friend Req';
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        sendFriendRequest(user);
                    });
                    li.appendChild(btn);
                } else {
                    addCallButtons(li, user, true);
                }
                list.appendChild(li);
            });
        }

        // Pending requests (unchanged)
        function updatePending() {
            const list = document.getElementById('pending-list');
            list.innerHTML = '';
            pendingReqs.forEach((requester) => {
                const li = document.createElement('li');
                li.textContent = requester;
                const btn = document.createElement('button');
                btn.classList.add('small');
                btn.textContent = 'Accept';
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    acceptFriend(requester);
                });
                li.appendChild(btn);
                list.appendChild(li);
            });
        }

        function acceptFriend(requester) {
            myFriends.push(requester);
            set(ref(db, `friends/${currentUsername}`), myFriends);

            get(ref(db, `friends/${requester}`)).then((snap) => {
                let tf = snap.val() || [];
                if (!tf.includes(currentUsername)) tf.push(currentUsername);
                set(ref(db, `friends/${requester}`), tf);
            });

            pendingReqs = pendingReqs.filter(p => p !== requester);
            set(ref(db, `friendRequests/${currentUsername}`), pendingReqs);
        }

        function sendFriendRequest(to) {
            if (myFriends.includes(to)) {
                alert('Already friends');
                return;
            }
            get(ref(db, `friendRequests/${to}`)).then((snap) => {
                let reqs = snap.val() || [];
                if (!reqs.includes(currentUsername)) {
                    reqs.push(currentUsername);
                    set(ref(db, `friendRequests/${to}`), reqs);
                    alert(`Friend request sent to ${to}`);
                } else {
                    alert('Request already sent');
                }
            });
        }

        // Friends - Add call buttons
        function updateFriends() {
            const list = document.getElementById('friend-list');
            list.innerHTML = '';
            myFriends.forEach((friend) => {
                const li = document.createElement('li');
                li.textContent = friend;
                li.addEventListener('click', () => privMsg(friend));
                addCallButtons(li, friend, true);
                list.appendChild(li);
            });
        }

        // Private Messaging (unchanged)
        function privMsg(user) {
            const [u1, u2] = [currentUsername, user].sort();
            currentLobby = `priv_${u1}_${u2}`;
            currentPriv = user;
            updateLobbies();
            updateMessages();
        }

        // Messages (unchanged)
        document.getElementById('send-btn').addEventListener('click', sendMessage);
        document.getElementById('message-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        function sendMessage() {
            const input = document.getElementById('message-input');
            const msg = input.value.trim();
            if (!msg || !currentUsername) return;
            const messagesRef = ref(db, `lobbies/${currentLobby}/messages`);
            push(messagesRef, { from: currentUsername, text: msg, timestamp: Date.now() });
            input.value = '';
        }

        function updateMessages() {
            const messagesDiv = document.getElementById('messages');
            messagesDiv.innerHTML = '';
            if (currentMessagesListener) {
                currentMessagesListener();
            }
            ensureLobby(currentLobby);
            const messagesRef = ref(db, `lobbies/${currentLobby}/messages`);
            currentMessagesListener = onChildAdded(messagesRef, (snap) => {
                const m = snap.val();
                const msgDiv = document.createElement('div');
                msgDiv.classList.add('message', m.from === currentUsername ? 'own' : '');
                if (currentPriv) msgDiv.classList.add('private');
                msgDiv.innerHTML = `<strong>${m.from}:</strong> ${m.text} <small>${new Date(m.timestamp).toLocaleTimeString()}</small>`;
                messagesDiv.appendChild(msgDiv);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            });
        }

        // Logout
        document.getElementById('logout').addEventListener('click', async () => {
            if (currentUser) {
                await update(ref(db, `users/${currentUser.uid}`), { online: false });
                await signOut(auth);
            }
        });
    </script>
</body>
</html>
